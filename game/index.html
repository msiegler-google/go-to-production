<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 - Go To Space</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #050505;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            border: 4px solid #003b00;
            box-sizing: border-box;
            cursor: crosshair;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%,
                    rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg,
                    rgba(255, 0, 0, 0.03),
                    rgba(0, 255, 0, 0.01),
                    rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes flicker {
            0% {
                opacity: 0.99;
            }

            5% {
                opacity: 0.95;
            }

            10% {
                opacity: 0.99;
            }

            100% {
                opacity: 1;
            }
        }

        .flicker {
            animation: flicker 0.15s infinite;
        }
    </style>
</head>

<body>
    <div id="game-container" class="flicker">
        <div class="scanlines"></div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const COLORS = {
            phosphor: '#00ff41',
            dim: '#008822',
            locked: '#004411',
            bg: '#050505',
            alert: '#ff3300',
            prestige: '#00ffff',
            white: '#ffffff',
            gold: '#ffd700',
            psycho: '#ccff00',
            gray: '#888888'
        };

        const getNinesPercent = (lvl) => 100 - (10 / Math.pow(10, lvl));

        const MILESTONES = [
            { lvl: 0, name: "BRITTLE_ROOTS", incidents: ["MANUAL_ERROR", "LAPTOP_CRASH"], desc: "Manual toil on localhost." },
            { lvl: 1, name: "TEST_AUTO", incidents: ["TEST_FLAKE", "ASSERT_FAIL"], desc: "Verifying logic before commit." },
            { lvl: 2, name: "CI_PIPELINE", incidents: ["JENKINS_OOM", "BUILD_CRASH"], desc: "Continuous automated builds." },
            { lvl: 3, name: "CD_ROLLOUT", incidents: ["ARTIFACT_LOSS", "DEPLOY_TIMEOUT"], desc: "Pushing to staging environments." },
            { lvl: 4, name: "MONITORING", incidents: ["METRIC_LAG", "LOG_STORM"], desc: "Observing system health." },
            { lvl: 5, name: "SLO_POLICIES", incidents: ["BUDGET_BURN", "BURN_SPIKE"], desc: "Defining reliability targets." },
            { lvl: 6, name: "ON_CALL", incidents: ["FAT_FINGER", "PAGE_FATIGUE"], desc: "Human response to failure." },
            { lvl: 7, name: "POST_MORTEM", incidents: ["RECURRING_BUG", "BLAME_GAME"], desc: "Learning from system outages." },
            { lvl: 8, name: "AUTO_SCALE", incidents: ["NODE_THRASHING", "POD_EVICTION"], desc: "Elastic resource management." },
            { lvl: 9, name: "CANARY_TEST", incidents: ["TRAFFIC_SKEW", "SHADOW_FAILURE"], desc: "Validating with partial traffic." },
            { lvl: 10, name: "CHAOS_ENGR", incidents: ["RANDOM_KILL", "STATE_LOSS"], desc: "Injecting failure for resilience." },
            { lvl: 11, name: "MULTI_REGION", incidents: ["BGP_HIJACK", "REGION_OUTAGE"], desc: "Global distribution of nodes." },
            { lvl: 12, name: "ORBITAL_SHIFT", incidents: ["COSMIC_RAY", "THERMAL_DIP"], desc: "Exiting terrestrial dependency." },
            { lvl: 13, name: "WAR_GAMES", incidents: ["SIMULATION_LOOP", "LOGIC_BOMB", "ENTROPY_MAX"], desc: "The only winning move is..." }
        ];

        const state = {
            version: "5.7",
            ru: 0,
            ruForLevel: 0,
            totalRuInception: 0,
            uptimeLevel: 0,
            smoothLevel: 0,
            visualNines: 90,
            logicFragments: 0,
            ap: 0,
            directives: {
                velocity: 0,
                reliability: 0,
                observability: 0
            },
            errorBudget: 100,
            isFrozen: false,
            isPaused: false,
            isWarGames: false,
            wonGame: false,
            lastTick: performance.now(),
            terminalLines: ["BOOTING SRE_OS v5.7...", "HEADER PROTOCOL INITIALIZED."],
            shake: 0,
            incidents: [],
            upgrades: [
                { id: 'script', name: 'BASH_CRON', cost: 15, count: 0, ruPerSec: 2.5, req: 0, desc: 'Reducing manual toil.' },
                { id: 'ci', name: 'CI_PIPELINE', cost: 250, count: 0, ruPerSec: 18.0, req: 2, desc: 'Automated delivery.' },
                { id: 'prom', name: 'PROM_STACK', cost: 2000, count: 0, ruPerSec: 150.0, req: 4, desc: 'Visibility layer.' },
                { id: 'oncall', name: 'PAGER_DUTY', cost: 15000, count: 0, ruPerSec: 1000.0, req: 6, desc: 'Human mitigation.' },
                { id: 'k8s', name: 'K8S_PLANE', cost: 180000, count: 0, ruPerSec: 8000.0, req: 8, desc: 'Pod orchestration.' },
                { id: 'chaos', name: 'MONKEY_LOGIC', cost: 2000000, count: 0, ruPerSec: 75000.0, req: 10, desc: 'Resilience testing.' }
            ],
            autoHeal: {
                level: 0,
                cost: 5,
                power: 0
            },
            buttons: [],
            animTimer: 0,
            broccoliWander: { x: 0, y: 0 },
            infraScroll: 0,
            infraHeight: 350
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        window.addEventListener('wheel', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            if (mx < 500 && my > 500) {
                state.infraScroll -= e.deltaY * 0.5;
                const maxScroll = -(state.upgrades.length * 50 - state.infraHeight + 20);
                if (state.infraScroll > 0) state.infraScroll = 0;
                if (state.infraScroll < maxScroll) state.infraScroll = maxScroll;
            }
        });

        function addTerminalLine(text) {
            state.terminalLines.push(`> ${text}`);
            if (state.terminalLines.length > 6) state.terminalLines.shift();
        }

        function triggerIncident() {
            if (state.isWarGames) return;
            const currentPool = [];
            for (let i = 0; i <= state.uptimeLevel; i++) {
                currentPool.push(...MILESTONES[i].incidents);
            }
            const name = currentPool[Math.floor(Math.random() * currentPool.length)];
            const behaviors = ["STATIC", "PULSE", "SHAKE"];
            const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
            const decayReduction = 1 - (state.directives.reliability * 0.05);
            state.incidents.push({
                id: Date.now(),
                name: name,
                behavior: behavior,
                x: 400 + Math.random() * (canvas.width - 800),
                y: 200 + Math.random() * (canvas.height - 500),
                radius: 45,
                decay: (0.03 + (state.uptimeLevel * 0.02)) * decayReduction,
                age: 0
            });
            state.shake = 15;
            addTerminalLine(`ALERT: ${name} DETECTED!`);
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            for (const btn of state.buttons) {
                if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
                    btn.onClick();
                    return;
                }
            }
            if (state.isPaused || state.wonGame) return;
            for (let i = state.incidents.length - 1; i >= 0; i--) {
                const inc = state.incidents[i];
                const dist = Math.sqrt((mx - inc.x) ** 2 + (my - inc.y) ** 2);
                if (dist < inc.radius) {
                    state.incidents.splice(i, 1);
                    state.errorBudget = Math.min(100 + (state.directives.reliability * 10), state.errorBudget + 8);
                    const dropChance = 0.4 + (state.uptimeLevel * 0.05) + (state.directives.observability * 0.1);
                    if (Math.random() < dropChance) {
                        state.logicFragments++;
                        addTerminalLine(`SCAVENGED: LOGIC_FRAGMENT [+1]`);
                    }
                    addTerminalLine(`MITIGATED: ${inc.name}`);
                    return;
                }
            }
            if (!state.isFrozen && state.errorBudget > 1) {
                const apMulti = 1 + (state.directives.velocity * 0.5);
                const gain = 3.0 * apMulti;
                state.ru += gain;
                state.ruForLevel += gain;
                state.totalRuInception += gain;
                state.errorBudget -= 3.0;
                state.shake = 2.5;
            }
        });

        function prestige() {
            if (state.uptimeLevel < 3) return;
            const earnedAP = Math.max(1, (state.uptimeLevel - 2) * 5);
            state.ap += earnedAP;
            state.uptimeLevel = 0;
            state.smoothLevel = 0;
            state.visualNines = 90;
            state.ru = 0;
            state.ruForLevel = 0;
            state.upgrades.forEach(u => {
                u.count = 0;
                u.cost = u.id === 'script' ? 15 : u.id === 'ci' ? 250 : u.id === 'prom' ? 2000 : u.id === 'oncall' ? 15000 : u.id === 'k8s' ? 180000 : 2000000;
            });
            state.incidents = [];
            state.errorBudget = 100 + (state.directives.reliability * 10);
            addTerminalLine(`GLOBAL POST-MORTEM: EARNED ${earnedAP} ARCH_POINTS.`);
        }

        function update() {
            const now = performance.now();
            const dt = (now - state.lastTick) / 1000;
            state.lastTick = now;
            if (state.isPaused || state.wonGame) return;
            state.animTimer += dt;
            state.broccoliWander.x = Math.sin(state.animTimer * 0.5) * 40;
            state.broccoliWander.y = Math.cos(state.animTimer * 0.7) * 30;
            if (state.isWarGames) {
                state.visualNines += (100 - state.visualNines) * 0.05;
                if (state.visualNines > 99.999999) {
                    state.visualNines = 99.9 + (Math.random() * 0.09);
                }
                return;
            }
            const healMulti = 1 + (state.directives.observability * 0.4);
            if (state.incidents.length > 0 && state.autoHeal.power > 0) {
                if (Math.random() < (state.autoHeal.power * healMulti * dt)) {
                    const resolved = state.incidents.shift();
                    addTerminalLine(`AUTO-HEALED: ${resolved.name}`);
                    state.errorBudget = Math.min(100 + (state.directives.reliability * 10), state.errorBudget + 2);
                }
            }
            let passive = 0;
            state.upgrades.forEach(u => passive += u.count * u.ruPerSec);
            if (!state.isFrozen) {
                const apMulti = 1 + (state.directives.velocity * 0.5);
                const gain = passive * dt * apMulti;
                state.ru += gain;
                state.ruForLevel += gain;
                state.totalRuInception += gain;
            }
            const nextNineCost = Math.pow(10, state.uptimeLevel + 1.2);
            const levelProgress = Math.min(0.999, state.ruForLevel / nextNineCost);
            state.smoothLevel = state.uptimeLevel + levelProgress;
            let incidentDecayTotal = 0;
            state.incidents.forEach(inc => incidentDecayTotal += inc.decay);
            const targetNines = getNinesPercent(state.smoothLevel);
            state.visualNines += (targetNines - state.visualNines) * 0.12;
            if (state.incidents.length > 0) {
                state.visualNines -= incidentDecayTotal * dt;
                if (state.visualNines < 90) state.visualNines = 90;
            }
            const recoveryMulti = 1 + (state.directives.reliability * 0.3);
            if (state.errorBudget < 100 + (state.directives.reliability * 10)) {
                state.errorBudget += (state.isFrozen ? 25 : 8) * recoveryMulti * dt;
                if (state.isFrozen && state.errorBudget >= 100) state.isFrozen = false;
            }
            if (state.errorBudget <= 0) { state.isFrozen = true; state.errorBudget = 0; }
            const complexity = (state.upgrades.reduce((a, b) => a + b.count, 0) * 0.0001) + (state.uptimeLevel * 0.0015);
            if (Math.random() < (0.003 + complexity) && !state.isFrozen) triggerIncident();
            state.shake *= 0.93;
        }

        function drawBroccoli(x, y, lvl) {
            const p = 6 + (lvl * 1.5);
            const bob = Math.sin(state.animTimer * 1.5) * (10 + lvl * 2);
            const sway = Math.sin(state.animTimer * 0.8) * 0.02;
            ctx.save();
            ctx.translate(x + state.broccoliWander.x, y + state.broccoliWander.y + bob);
            ctx.rotate(sway);
            const alpha = Math.max(0, 0.75 * (1 - (state.smoothLevel / 13)));
            ctx.globalAlpha = state.isPaused ? alpha * 0.5 : alpha;
            const isPanicking = (state.incidents.length > 0 || state.isFrozen) && !state.isWarGames;
            const treeColor = isPanicking ? COLORS.alert : COLORS.psycho;
            ctx.shadowBlur = 20 + (lvl * 5);
            ctx.shadowColor = treeColor;
            ctx.fillStyle = COLORS.dim;
            const trunkWidth = p * 4, trunkHeight = p * 8;
            ctx.fillRect(-trunkWidth / 2, 0, trunkWidth, trunkHeight);
            ctx.fillStyle = treeColor;
            const radius = p * (8 + lvl * 1.2);
            ctx.beginPath();
            ctx.arc(0, -p * 2, radius, 0, Math.PI * 2);
            ctx.fill();
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const fx = Math.cos(angle) * radius * 0.8, fy = Math.sin(angle) * radius * 0.8 - p * 2;
                ctx.beginPath(); ctx.arc(fx, fy, radius * 0.5, 0, Math.PI * 2); ctx.fill();
            }
            if (lvl >= 1) {
                const faceY = -p * 3;
                ctx.fillStyle = COLORS.white;
                ctx.fillRect(-p * 4, faceY, p * 3, p); ctx.fillRect(p, faceY, p * 3, p);
                ctx.fillStyle = isPanicking ? COLORS.alert : COLORS.prestige;
                ctx.fillRect(-p * 2.5, faceY, p, p); ctx.fillRect(p * 1.5, faceY, p, p);
            }
            ctx.restore();
        }

        function drawPulseBox(x, y, w, h, color) {
            ctx.save();
            const pulse = 0.5 + Math.sin(state.animTimer * 6) * 0.5;
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.2 + pulse * 0.6;
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (state.wonGame) {
                ctx.fillStyle = COLORS.phosphor;
                ctx.textAlign = "center";
                ctx.font = "bold 40px 'Courier New'";
                ctx.fillText("SYSTEM STATUS: 1", canvas.width / 2, canvas.height / 2 - 40);
                ctx.font = "20px 'Courier New'";
                ctx.fillText("THE ONLY WINNING MOVE IS NOT TO DEPLOY.", canvas.width / 2, canvas.height / 2 + 20);
                return;
            }

            // GAME TITLE HEADER
            ctx.save();
            ctx.textAlign = "center";
            ctx.fillStyle = COLORS.gray;
            ctx.font = "14px 'Courier New'";
            ctx.fillText(`100% :Go To space (v ${state.version})`, canvas.width / 2, 25);
            ctx.restore();

            if (state.isPaused) {
                ctx.fillStyle = "rgba(0,0,0,0.85)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.textAlign = "center";
                ctx.fillStyle = COLORS.phosphor;
                ctx.font = "bold 40px 'Courier New'";
                ctx.fillText("STANDUP IN PROGRESS", canvas.width / 2, canvas.height / 2);
                ctx.font = "16px 'Courier New'";
                ctx.fillText("SYSTEM WORK HALTED.", canvas.width / 2, canvas.height / 2 + 50);
                ctx.restore();
            }

            ctx.save();
            if (state.shake > 1 && !state.isPaused) ctx.translate((Math.random() - 0.5) * state.shake, (Math.random() - 0.5) * state.shake);
            ctx.strokeStyle = COLORS.dim;
            ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

            state.buttons = [];

            // Architecture Directives
            ctx.textAlign = "left";
            ctx.font = "14px 'Courier New'";
            ctx.fillStyle = COLORS.prestige;
            ctx.fillText(`--- ARCHITECTURE DIRECTIVES [AP: ${state.ap}] ---`, 50, 45);

            const dirs = ['velocity', 'reliability', 'observability'];
            dirs.forEach((d, i) => {
                const x = 50 + (i * 200);
                const canAfford = state.ap > 0;
                if (canAfford) drawPulseBox(x - 5, 50, 185, 30, COLORS.prestige);
                ctx.fillStyle = canAfford ? COLORS.prestige : COLORS.locked;
                ctx.fillText(`[+] ${d.toUpperCase()}: ${state.directives[d]}`, x, 70);
                state.buttons.push({ x: x, y: 55, w: 180, h: 25, onClick: () => { if (state.ap > 0) { state.ap--; state.directives[d]++; addTerminalLine(`DIRECTIVE UPDATED: ${d.toUpperCase()}.`); } } });
            });

            // Center Panel
            ctx.textAlign = "center";
            const milestone = MILESTONES[state.uptimeLevel] || MILESTONES[MILESTONES.length - 1];
            const nextMilestone = MILESTONES[state.uptimeLevel + 1];
            ctx.font = "16px 'Courier New'";
            ctx.fillStyle = COLORS.dim;
            ctx.fillText(`INCEPTION_CRU: ${Math.floor(state.totalRuInception)}`, canvas.width / 2, 140);
            ctx.fillStyle = state.isWarGames ? COLORS.alert : COLORS.phosphor;
            ctx.font = "bold 58px 'Courier New'";
            ctx.fillText(`STAGE: ${milestone.name}`, canvas.width / 2, 195);
            ctx.font = "bold 72px 'Courier New'";
            const precision = Math.max(6, state.uptimeLevel + 2);
            ctx.fillText(state.visualNines.toFixed(precision) + "%", canvas.width / 2, 260);

            if (state.isWarGames) {
                drawPulseBox(canvas.width / 2 - 130, 85, 260, 45, COLORS.alert);
                ctx.fillStyle = COLORS.alert;
                ctx.font = "bold 20px 'Courier New'";
                ctx.fillText("[!] ABORT_SIMULATION", canvas.width / 2, 110);
                state.buttons.push({ x: canvas.width / 2 - 125, y: 90, w: 250, h: 40, onClick: () => { state.wonGame = true; } });
            } else if (nextMilestone) {
                const cost = Math.pow(10, state.uptimeLevel + 1.2);
                const canAfford = state.ruForLevel >= cost;
                if (canAfford) drawPulseBox(canvas.width / 2 - 200, 85, 400, 40, COLORS.phosphor);
                ctx.fillStyle = canAfford ? COLORS.phosphor : COLORS.dim;
                ctx.font = "16px 'Courier New'";
                ctx.fillText(`NEXT: [${nextMilestone.name}] REQ: ${Math.floor(cost)} RU`, canvas.width / 2, 110);
                state.buttons.push({ x: canvas.width / 2 - 200, y: 85, w: 400, h: 40, onClick: () => { if (!state.isPaused && state.ruForLevel >= cost) { state.ruForLevel -= cost; state.uptimeLevel++; addTerminalLine(`UNLOCKED: ${nextMilestone.name}.`); if (nextMilestone.name === "WAR_GAMES") state.isWarGames = true; } } });
            }

            if (!state.isWarGames) {
                const apMulti = 1 + (state.directives.velocity * 0.5);
                let passiveRate = 0;
                state.upgrades.forEach(u => passiveRate += u.count * u.ruPerSec * apMulti);
                ctx.font = "18px 'Courier New'";
                ctx.fillStyle = COLORS.phosphor;
                ctx.fillText(`RELIABILITY UNITS: ${Math.floor(state.ru)} | THROUGHPUT: ${passiveRate.toFixed(1)} RU/s`, canvas.width / 2, 310);
                ctx.fillStyle = COLORS.prestige;
                ctx.fillText(`LOGIC FRAGMENTS: ${state.logicFragments}`, canvas.width / 2, 335);
            }

            const bW = 480, bX = canvas.width / 2 - bW / 2, bY = 360;
            ctx.strokeStyle = COLORS.dim;
            ctx.strokeRect(bX, bY, bW, 22);
            ctx.fillStyle = state.isFrozen ? COLORS.alert : COLORS.phosphor;
            ctx.fillRect(bX + 4, bY + 4, (bW - 8) * (state.errorBudget / (100 + state.directives.reliability * 10)), 14);

            // Infrastructure Panel
            ctx.save();
            ctx.textAlign = "left";
            ctx.fillStyle = COLORS.dim;
            ctx.fillText("--- INFRASTRUCTURE (SCROLL) ---", 50, 500);
            const scrollAreaY = 515;
            ctx.beginPath();
            ctx.rect(40, scrollAreaY, 450, state.infraHeight);
            ctx.clip();
            const apMulti = 1 + (state.directives.velocity * 0.5);
            state.upgrades.forEach((u, i) => {
                const y = scrollAreaY + 30 + i * 55 + state.infraScroll;
                const unlocked = state.uptimeLevel >= u.req;
                const aff = state.ru >= u.cost;
                if (unlocked && !state.isWarGames) {
                    if (aff) drawPulseBox(45, y - 25, 420, 40, COLORS.phosphor);
                    ctx.fillStyle = aff ? COLORS.phosphor : COLORS.dim;
                    const contribution = (u.count * u.ruPerSec * apMulti).toFixed(1);
                    ctx.fillText(`[${u.count}] ${u.name} (${Math.floor(u.cost)} RU) | +${contribution} RU/s`, 50, y);
                    if (y > scrollAreaY && y < scrollAreaY + state.infraHeight) {
                        state.buttons.push({ x: 50, y: y - 10, w: 420, h: 35, onClick: () => { if (!state.isPaused && state.ru >= u.cost) { state.ru -= u.cost; u.count++; u.cost *= 1.8; addTerminalLine(`PROVISIONED: ${u.name}`); } } });
                    }
                } else if (!state.isWarGames) {
                    ctx.fillStyle = COLORS.locked;
                    ctx.fillText(`[LOCKED] REQ: ${MILESTONES[u.req].name}`, 50, y);
                }
            });
            ctx.restore();

            // Self Healing Panel
            ctx.textAlign = "center";
            ctx.fillStyle = COLORS.dim;
            const rightPanelX = canvas.width - 250;
            ctx.fillText("--- SELF-HEALING MODULES ---", rightPanelX, 500);
            const ahUnlocked = state.uptimeLevel >= 4;
            if (ahUnlocked) {
                const affAh = state.logicFragments >= state.autoHeal.cost;
                if (affAh) drawPulseBox(rightPanelX - 105, 505, 210, 50, COLORS.prestige);
                ctx.fillStyle = affAh ? COLORS.prestige : COLORS.dim;
                ctx.fillText(`[LVL ${state.autoHeal.level}] AUTO-REMEDIATOR`, rightPanelX, 530);
                ctx.font = "12px 'Courier New'";
                ctx.fillText(`COST: ${state.autoHeal.cost} FRAGMENTS`, rightPanelX, 545);
                state.buttons.push({ x: rightPanelX - 100, y: 515, w: 200, h: 40, onClick: () => { if (state.logicFragments >= state.autoHeal.cost) { state.logicFragments -= state.autoHeal.cost; state.autoHeal.level++; state.autoHeal.power += 0.2; state.autoHeal.cost = Math.floor(state.autoHeal.cost * 2.2); addTerminalLine("UPGRADED AUTO-REMEDIATION."); } } });
            } else {
                ctx.fillStyle = COLORS.locked;
                ctx.fillText("[LOCKED] REQ: MONITORING", rightPanelX, 530);
            }

            // Global Post-Mortem
            if (state.uptimeLevel >= 3 && !state.isWarGames) {
                const prestigeY = 650;
                drawPulseBox(rightPanelX - 200, prestigeY - 5, 400, 40, COLORS.prestige);
                ctx.fillStyle = COLORS.prestige;
                ctx.fillText(`[!] GLOBAL POST-MORTEM (+${Math.max(1, state.uptimeLevel - 2) * 5} AP)`, rightPanelX, prestigeY + 20);
                state.buttons.push({ x: rightPanelX - 200, y: prestigeY, w: 400, h: 30, onClick: prestige });
            }

            // Pause Button
            const pauseText = state.isPaused ? "[RESUME_ON_CALL]" : "[INITIATE_STANDUP]";
            ctx.textAlign = "right";
            ctx.fillStyle = COLORS.white;
            if (state.isPaused) drawPulseBox(canvas.width - 250, 30, 200, 30, COLORS.white);
            ctx.fillText(pauseText, canvas.width - 50, 45);
            state.buttons.push({ x: canvas.width - 250, y: 30, w: 200, h: 30, onClick: () => { state.isPaused = !state.isPaused; } });

            drawBroccoli(canvas.width - 250, canvas.height - 350, state.uptimeLevel);
            state.incidents.forEach(inc => {
                ctx.save();
                let r = inc.radius;
                if (inc.behavior === "PULSE") r = inc.radius * (1 + Math.sin(state.animTimer * 10) * 0.2);
                else if (inc.behavior === "SHAKE") ctx.translate(Math.random() * 6 - 3, Math.random() * 6 - 3);
                ctx.strokeStyle = COLORS.alert; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(inc.x, inc.y, r, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = COLORS.alert; ctx.textAlign = "center";
                ctx.font = "bold 13px 'Courier New'"; ctx.fillText(inc.name, inc.x, inc.y - 4);
                ctx.restore();
            });
            ctx.textAlign = "left"; ctx.fillStyle = COLORS.dim; ctx.font = "13px 'Courier New'";
            state.terminalLines.forEach((l, i) => ctx.fillText(l, canvas.width - 450, canvas.height - 180 + i * 18));
            ctx.restore();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        loop();
    </script>
</body>

</html>