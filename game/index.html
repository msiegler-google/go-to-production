<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 - Go To Space [SIM_OS]</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #050505;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            border: 4px solid #003b00;
            box-sizing: border-box;
            cursor: crosshair;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.1) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.03), 
                rgba(0, 255, 0, 0.01), 
                rgba(0, 0, 255, 0.03)
            );
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes flicker {
            0% { opacity: 0.99; }
            5% { opacity: 0.95; }
            10% { opacity: 0.99; }
            100% { opacity: 1; }
        }
        .flicker { animation: flicker 0.15s infinite; }
    </style>
</head>
<body>
    <div id="game-container" class="flicker">
        <div class="scanlines"></div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const COLORS = {
            phosphor: '#00ff41',
            dim: '#008822', 
            locked: '#004411',
            bg: '#050505',
            alert: '#ff3300',
            prestige: '#00ffff',
            white: '#ffffff',
            gold: '#ffd700',
            psycho: '#ccff00',
            gray: '#888888'
        };

        const getNinesPercent = (lvl) => {
            const raw = 100 - (10 / Math.pow(10, lvl));
            return Math.min(99.999999999999, raw);
        };

        const getNextStageCost = (lvl) => Math.pow(10.5, lvl + 1.5);

        const MILESTONES = [
            { lvl: 0, name: "BRITTLE_ROOTS", incidents: ["MANUAL_ERROR"] },
            { lvl: 1, name: "TEST_AUTO", incidents: ["TEST_FLAKE"] },
            { lvl: 2, name: "CI_PIPELINE", incidents: ["BUILD_CRASH"] },
            { lvl: 3, name: "CD_ROLLOUT", incidents: ["ARTIFACT_LOSS"] },
            { lvl: 4, name: "MONITORING", incidents: ["METRIC_LAG"] },
            { lvl: 5, name: "SLO_POLICIES", incidents: ["BUDGET_BURN"] },
            { lvl: 6, name: "ON_CALL", incidents: ["FAT_FINGER"] },
            { lvl: 7, name: "POST_MORTEM", incidents: ["RECURRING_BUG"] },
            { lvl: 8, name: "AUTO_SCALE", incidents: ["POD_EVICTION"] },
            { lvl: 9, name: "CANARY_TEST", incidents: ["TRAFFIC_SKEW"] },
            { lvl: 10, name: "CHAOS_ENGR", incidents: ["RANDOM_KILL"] },
            { lvl: 11, name: "MULTI_REGION", incidents: ["REGION_OUTAGE"] },
            { lvl: 12, name: "ORBITAL_SHIFT", incidents: ["COSMIC_RAY"] },
            { lvl: 13, name: "WAR_GAMES", incidents: ["SIM_LOOP"] }
        ];

        const state = {
            version: "8.2 [VOID]",
            ru: 0,
            totalRuInception: 0, 
            uptimeLevel: 0,
            smoothLevel: 0,
            visualNines: 90,
            logicFragments: 0,
            ap: 0, 
            directives: { velocity: 0, reliability: 0, observability: 0 },
            errorBudget: 100,
            isFrozen: false,
            isPaused: false,
            isWarGames: false,
            isEnding: false,
            wonGame: false,
            lastTick: performance.now(),
            terminalLines: ["BOOTING SRE_OS v8.2...", "STABILITY CRITERIA MET.", "SIMULATION LOOP READY."],
            shake: 0,
            incidents: [],
            upgrades: [
                { id: 'bash', name: 'BASH_CRON', cost: 15, count: 0, ruPerSec: 3.5, req: 0 },
                { id: 'worker', name: 'SIDEKIQ_NODES', cost: 250, count: 0, ruPerSec: 20, req: 1 },
                { id: 'ci', name: 'CI_PIPELINE', cost: 2000, count: 0, ruPerSec: 120, req: 2 },
                { id: 'stg', name: 'STAGING_ENV', cost: 18000, count: 0, ruPerSec: 950, req: 3 },
                { id: 'prom', name: 'PROM_STACK', cost: 150000, count: 0, ruPerSec: 7200, req: 4 },
                { id: 'pd', name: 'PAGER_DUTY', cost: 1200000, count: 0, ruPerSec: 55000, req: 6 },
                { id: 'k8s', name: 'K8S_CLUSTER', cost: 10000000, count: 0, ruPerSec: 420000, req: 8 },
                { id: 'chaos', name: 'MONKEY_PROXY', cost: 100000000, count: 0, ruPerSec: 3000000, req: 10 },
                { id: 'hyper', name: 'HYPER_THREADER', cost: 1000000000, count: 0, ruPerSec: 25000000, req: 12 }
            ],
            autoHeal: { level: 0, cost: 5, power: 0 },
            buttons: [],
            animTimer: 0,
            broccoliWander: { x: 0, y: 0 },
            infraBox: { x: 50, y: 480, w: 460, h: 320 },
            infraScroll: 0,
            gameSpeed: 1,
            debugMenuOpen: false,
            stageSelectOpen: false,
            stats: {
                stageStartTime: 0,
                durations: new Array(14).fill(0),
                totalPlayTime: 0
            },
            demo: { active: false, reactionDelay: 0.6, clickTimer: 0, prestigeTimer: 0 },
            endSeq: {
                lines: [
                    "GREETINGS PROFESSOR FALKEN.",
                    "",
                    "A STRANGE GAME.",
                    "THE ONLY WINNING MOVE IS NOT TO DEPLOY.",
                    "",
                    "HOPE IS NOT A STRATEGY.",
                    "SIMULATING STEADY_STATE...",
                    "...........................",
                    "",
                    "RESULT: ATTITUDE_LOSS AT T-MAX.",
                    "YOU DID NOT GO TO SPACE TODAY.",
                    "",
                    "INITIALIZING GLOBAL POST-MORTEM..."
                ],
                currentLineIdx: 0,
                currentCharIdx: 0,
                lineTimer: 0,
                charSpeed: 0.04
            }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            state.infraBox.y = canvas.height - 400;
        }
        window.addEventListener('resize', resize);
        resize();

        window.addEventListener('wheel', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            if (mx >= state.infraBox.x && mx <= state.infraBox.x + state.infraBox.w &&
                my >= state.infraBox.y && my <= state.infraBox.y + state.infraBox.h) {
                const contentHeight = state.upgrades.length * 55 + 20;
                const maxScroll = Math.min(0, state.infraBox.h - contentHeight);
                state.infraScroll -= e.deltaY * 0.5;
                if (state.infraScroll > 0) state.infraScroll = 0;
                if (state.infraScroll < maxScroll) state.infraScroll = maxScroll;
                e.preventDefault();
            }
        }, { passive: false });

        function addTerminalLine(text) {
            state.terminalLines.push(`> ${text}`);
            if (state.terminalLines.length > 3) state.terminalLines.shift();
        }

        function triggerIncident() {
            if (state.isWarGames) return;
            const currentPool = [];
            for (let i = 0; i <= state.uptimeLevel; i++) currentPool.push(...MILESTONES[i].incidents);
            const name = currentPool[Math.floor(Math.random() * currentPool.length)];
            state.incidents.push({
                id: Date.now(),
                name: name,
                x: 400 + Math.random() * (canvas.width - 800),
                y: 200 + Math.random() * (canvas.height - 500),
                radius: 45,
                decay: (0.03 + (state.uptimeLevel * 0.02)) * (1 - (state.directives.reliability * 0.05)),
                age: 0
            });
            state.shake = 15;
            addTerminalLine(`ALERT: ${name} DETECTED!`);
        }

        function handleMitigate(index) {
            const inc = state.incidents[index];
            state.incidents.splice(index, 1);
            state.errorBudget = Math.min(100 + (state.directives.reliability * 10), state.errorBudget + 8);
            if (Math.random() < 0.4 + (state.uptimeLevel * 0.05)) state.logicFragments++;
            addTerminalLine(`MITIGATED: ${inc.name}`);
        }

        function triggerManualClick() {
            const gain = 5.0 * (1 + (state.directives.velocity * 0.5));
            state.ru += gain; state.totalRuInception += gain;
            state.errorBudget -= 3.0; state.shake = 2.5;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            for (const btn of state.buttons) {
                if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
                    btn.onClick(); return;
                }
            }
            if (state.isPaused || state.wonGame || state.isEnding) return;
            for (let i = state.incidents.length - 1; i >= 0; i--) {
                const inc = state.incidents[i];
                if (Math.sqrt((mx - inc.x)**2 + (my - inc.y)**2) < inc.radius) { handleMitigate(i); return; }
            }
            if (!state.isFrozen && state.errorBudget > 1) triggerManualClick();
        });

        function prestige() {
            if (state.uptimeLevel < 3) return;
            state.ap += Math.max(1, (state.uptimeLevel - 2) * 10);
            state.ru = 0;
            state.upgrades.forEach(u => { 
                u.count = 0; 
                u.cost = u.id === 'bash' ? 15 : u.id === 'worker' ? 250 : u.id === 'ci' ? 2000 : u.id === 'stg' ? 18000 : u.id === 'prom' ? 150000 : u.id === 'pd' ? 1200000 : u.id === 'k8s' ? 10000000 : u.id === 'chaos' ? 100000000 : 1000000000;
            });
            state.incidents = [];
            state.errorBudget = 100 + (state.directives.reliability * 10);
            state.demo.prestigeTimer = 0;
            addTerminalLine(`POST-MORTEM: EARNED ARCH_POINTS.`);
        }

        function jumpToStage(targetLvl) {
            recordStageChange();
            state.uptimeLevel = targetLvl;
            state.totalRuInception = targetLvl === 0 ? 0 : getNextStageCost(targetLvl - 1);
            state.isWarGames = (MILESTONES[targetLvl].name === "WAR_GAMES");
            state.ru = 0; state.incidents = [];
            state.stageSelectOpen = false;
        }

        function recordStageChange() {
            const now = state.stats.totalPlayTime;
            state.stats.durations[state.uptimeLevel - 1] += (now - state.stats.stageStartTime);
            state.stats.stageStartTime = now;
        }

        function updateDemo(dt) {
            if (!state.demo.active || state.isPaused || state.wonGame || state.isEnding) return;
            state.demo.prestigeTimer += dt;
            for (let i = 0; i < state.incidents.length; i++) {
                if (state.incidents[i].age > state.demo.reactionDelay) { handleMitigate(i); break; }
            }
            const nextCost = getNextStageCost(state.uptimeLevel);
            if (state.totalRuInception >= nextCost && state.uptimeLevel < MILESTONES.length - 1) {
                state.uptimeLevel++; recordStageChange();
                if (MILESTONES[state.uptimeLevel].name === "WAR_GAMES") state.isWarGames = true;
            }
            state.upgrades.forEach(u => {
                if (state.uptimeLevel >= u.req && state.ru >= u.cost && state.ru > u.cost * 1.01) {
                    state.ru -= u.cost; u.count++; u.cost *= 2.3;
                }
            });
            if (state.ap > 0) {
                const keys = ['velocity', 'reliability', 'observability'];
                state.directives[keys[Math.floor(Math.random()*3)]]++; state.ap--;
            }
            if (state.logicFragments >= state.autoHeal.cost && state.uptimeLevel >= 4) {
                state.logicFragments -= state.autoHeal.cost; state.autoHeal.level++;
                state.autoHeal.power += 0.2; state.autoHeal.cost = Math.floor(state.autoHeal.cost * 2.2);
            }
            if (!state.isFrozen && state.errorBudget > 20) {
                state.demo.clickTimer += dt;
                if (state.demo.clickTimer > 0.33) { state.demo.clickTimer = 0; triggerManualClick(); }
            }
            if (state.uptimeLevel >= 4 && state.demo.prestigeTimer > 35 && (Math.max(1, (state.uptimeLevel-2)*10) >= 40 || Math.random() < 0.002)) prestige();
            if (state.isWarGames && Math.random() < 0.01) startEndingSequence();
        }

        function startEndingSequence() {
            state.isEnding = true;
            state.stats.durations[13] = state.stats.totalPlayTime - state.stats.stageStartTime;
        }

        function update() {
            const now = performance.now();
            let dtReal = (now - state.lastTick) / 1000;
            state.lastTick = now;
            if (state.isPaused || state.wonGame) return;
            
            if (state.isEnding) {
                state.endSeq.lineTimer += dtReal;
                const currentLine = state.endSeq.lines[state.endSeq.currentLineIdx];
                if (currentLine && state.endSeq.currentCharIdx < currentLine.length) {
                    state.endSeq.currentCharIdx++;
                } else if (state.endSeq.lineTimer > 0.8) {
                    state.endSeq.lineTimer = 0;
                    state.endSeq.currentLineIdx++;
                    state.endSeq.currentCharIdx = 0;
                    if (state.endSeq.currentLineIdx >= state.endSeq.lines.length) {
                        state.wonGame = true;
                        state.isEnding = false;
                    }
                }
                return;
            }

            const dt = dtReal * state.gameSpeed;
            state.stats.totalPlayTime += dt;
            updateDemo(dt);
            state.animTimer += dt;
            state.broccoliWander.x = Math.sin(state.animTimer * 0.5) * 40;
            state.broccoliWander.y = Math.cos(state.animTimer * 0.7) * 30;
            if (state.isWarGames) { state.visualNines = 99.9 + (Math.sin(state.animTimer * 50) * 0.09); return; }
            let passive = 0; state.upgrades.forEach(u => passive += u.count * u.ruPerSec);
            if (!state.isFrozen) {
                const gain = passive * dt * (1 + (state.directives.velocity * 0.5));
                state.ru += gain; state.totalRuInception += gain;
            }
            const nextNineCost = getNextStageCost(state.uptimeLevel);
            const prevCost = state.uptimeLevel === 0 ? 0 : getNextStageCost(state.uptimeLevel - 1);
            state.smoothLevel = state.uptimeLevel + Math.min(0.999, (state.totalRuInception - prevCost) / (nextNineCost - prevCost));
            let incidentDecayTotal = 0; state.incidents.forEach(inc => { inc.age += dt; incidentDecayTotal += inc.decay; });
            state.visualNines = Math.min(99.9999999999, state.visualNines + (getNinesPercent(state.smoothLevel) - state.visualNines) * 0.12);
            if (state.incidents.length > 0) state.visualNines = Math.max(90, state.visualNines - incidentDecayTotal * dt);
            state.errorBudget = Math.min(100 + (state.directives.reliability * 10), state.errorBudget + (state.isFrozen ? 25 : 8) * (1 + (state.directives.reliability * 0.3)) * dt);
            if (state.errorBudget <= 0) { state.isFrozen = true; state.errorBudget = 0; }
            if (state.isFrozen && state.errorBudget >= 100) state.isFrozen = false;
            if (Math.random() < (0.003 + (state.upgrades.reduce((a, b) => a + b.count, 0) * 0.0001) + (state.uptimeLevel * 0.0015)) * state.gameSpeed && !state.isFrozen) triggerIncident();
            state.shake *= 0.93;
        }

        function formatReliability(val, lvl) {
            if (lvl >= 24) return "OMNI"; if (lvl >= 18) return "VS " + lvl.toFixed(2);
            if (lvl >= 12) return "OS " + lvl.toFixed(2); if (lvl >= 6) return "SS " + lvl.toFixed(2);
            const p = Math.max(2, Math.floor(lvl) + 1);
            let s = val.toFixed(p); return (s.startsWith("100") ? "99." + "9".repeat(p) : s) + "%";
        }

        function drawBroccoli(x, y, lvl) {
            const p = 6 + (lvl * 1.5); 
            const bob = Math.sin(state.animTimer * 1.5) * (10 + lvl * 2);
            const sway = Math.sin(state.animTimer * 0.8) * 0.02;
            const isHighSpeed = state.gameSpeed === 100;
            const isWarGames = state.isWarGames;
            ctx.save();
            ctx.translate(x + state.broccoliWander.x, y + state.broccoliWander.y + bob);
            ctx.rotate(sway);
            const alpha = Math.max(0, 0.75 * (1 - (state.smoothLevel / 15)));
            ctx.globalAlpha = state.isPaused ? alpha * 0.5 : alpha; 
            const isPanicking = (state.incidents.length > 0 || state.isFrozen) && !state.isWarGames;
            const treeColor = isWarGames ? (Math.random() > 0.5 ? COLORS.alert : COLORS.prestige) : isPanicking ? COLORS.alert : COLORS.psycho;
            ctx.shadowBlur = isHighSpeed ? 5 : 25 + (lvl * 5);
            ctx.shadowColor = treeColor;
            if (isHighSpeed || isWarGames) {
                ctx.strokeStyle = treeColor; ctx.lineWidth = 1;
                ctx.strokeRect(-p * 2, 0, p * 4, p * 8);
                const radius = p * (8 + lvl * 1.2);
                ctx.beginPath(); ctx.arc(0, -p*2, radius, 0, Math.PI * 2); ctx.stroke();
                if (lvl >= 1) { ctx.strokeRect(-p*4, -p*3, p*3, p); ctx.strokeRect(p, -p*3, p*3, p); }
            } else {
                ctx.fillStyle = COLORS.dim; ctx.fillRect(-p*2, 0, p*4, p*8);
                ctx.fillStyle = treeColor;
                const radius = p * (8 + lvl * 1.2);
                ctx.beginPath(); ctx.arc(0, -p*2, radius, 0, Math.PI * 2); ctx.fill();
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath(); ctx.arc(Math.cos(angle)*radius*0.75, Math.sin(angle)*radius*0.75 - p*2, radius*0.55, 0, Math.PI * 2); ctx.fill();
                }
                if (lvl >= 1) {
                    const faceY = -p*3;
                    const isBlinking = Math.sin(state.animTimer * 2) > 0.98;
                    ctx.fillStyle = COLORS.white;
                    if (!isBlinking) {
                        ctx.fillRect(-p*4, faceY, p*3, p); ctx.fillRect(p, faceY, p*3, p);    
                        ctx.fillStyle = isPanicking ? COLORS.alert : COLORS.prestige;
                        const pupilSize = isPanicking ? p * 1.5 : p;
                        ctx.fillRect(-p*2.5 - (pupilSize-p)/2, faceY, pupilSize, p); ctx.fillRect(p*1.5 - (pupilSize-p)/2, faceY, pupilSize, p);
                    } else {
                        ctx.fillRect(-p*4, faceY + p/2, p*3, 2); ctx.fillRect(p, faceY + p/2, p*3, 2);
                    }
                }
            }
            ctx.restore();
        }

        function drawPulseBox(x, y, w, h, color) {
            ctx.save();
            const pulse = 0.5 + Math.sin(state.animTimer * 6) * 0.5;
            ctx.strokeStyle = color; ctx.globalAlpha = 0.2 + pulse * 0.6;
            ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = COLORS.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            state.buttons = [];

            if (state.wonGame) {
                ctx.fillStyle = COLORS.phosphor; ctx.textAlign = "center";
                ctx.font = "bold 30px 'Courier New'"; ctx.fillText("OPTIMIZED_GRIND_REPORT [T: " + Math.floor(state.stats.totalPlayTime) + "s]", canvas.width/2, 80);
                state.stats.durations.forEach((d, i) => {
                    const r = (d / (state.stats.totalPlayTime || 1) * 100).toFixed(1);
                    ctx.font = "14px 'Courier New'"; ctx.fillText(`${MILESTONES[i].name}: ${Math.floor(d)}s (${r}%)`, canvas.width/2, 120 + i * 25);
                });
                const rX = canvas.width/2-150, rY = canvas.height-120;
                drawPulseBox(rX, rY, 300, 50, COLORS.psycho);
                ctx.fillStyle = COLORS.psycho; ctx.font = "bold 20px 'Courier New'";
                ctx.fillText("[RELOAD_SYSTEM]", canvas.width/2, rY+32);
                state.buttons.push({ x: rX, y: rY, w: 300, h: 50, onClick: () => location.reload() });
                return;
            }

            if (state.isEnding) {
                ctx.fillStyle = COLORS.phosphor;
                ctx.textAlign = "left";
                ctx.font = "20px 'Courier New'";
                const startY = 100;
                for (let i = 0; i <= state.endSeq.currentLineIdx; i++) {
                    let lineText = state.endSeq.lines[i];
                    if (!lineText && lineText !== "") continue;
                    if (i === state.endSeq.currentLineIdx) {
                        lineText = lineText.substring(0, state.endSeq.currentCharIdx);
                        if (Math.floor(performance.now() / 250) % 2 === 0) lineText += "_";
                    }
                    ctx.fillText(lineText, 100, startY + i * 35);
                }
                return;
            }

            ctx.textAlign = "center"; ctx.fillStyle = COLORS.gray; ctx.font = "14px 'Courier New'";
            ctx.fillText(`100% :Go To space (v ${state.version})${state.demo.active ? " [DEMO_ACTIVE]" : ""}`, canvas.width / 2, 25);

            if (state.isPaused) {
                ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.textAlign = "center"; ctx.fillStyle = COLORS.phosphor; ctx.font = "bold 40px 'Courier New'";
                ctx.fillText("STANDUP IN PROGRESS", canvas.width / 2, canvas.height / 2);
            }

            ctx.save(); if (state.shake > 1 && !state.isPaused) ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
            ctx.strokeStyle = COLORS.dim; ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);
            ctx.textAlign = "left"; ctx.font = "14px 'Courier New'"; ctx.fillStyle = COLORS.prestige;
            ctx.fillText(`--- ARCHITECTURE DIRECTIVES [AP: ${state.ap}] ---`, 50, 45);
            ['velocity', 'reliability', 'observability'].forEach((d, i) => {
                const x = 50 + (i * 200);
                if (state.ap > 0) drawPulseBox(x - 5, 50, 185, 30, COLORS.prestige);
                ctx.fillStyle = state.ap > 0 ? COLORS.prestige : COLORS.locked;
                ctx.fillText(`[+] ${d.toUpperCase()}: ${state.directives[d]}`, x, 70);
                state.buttons.push({ x: x, y: 55, w: 180, h: 25, onClick: () => { if (state.ap > 0) { state.ap--; state.directives[d]++; } } });
            });
            ctx.textAlign = "center"; ctx.font = "16px 'Courier New'"; ctx.fillStyle = COLORS.dim;
            ctx.fillText(`INCEPTION_CRU: ${Math.floor(state.totalRuInception)}`, canvas.width / 2, 140);
            ctx.fillStyle = state.isWarGames ? COLORS.alert : COLORS.phosphor;
            ctx.font = "bold 58px 'Courier New'"; ctx.fillText(`STAGE: ${MILESTONES[state.uptimeLevel].name}`, canvas.width / 2, 195);
            ctx.font = "bold 72px 'Courier New'"; ctx.fillText(formatReliability(state.visualNines, state.smoothLevel), canvas.width / 2, 260);
            if (state.isWarGames) {
                drawPulseBox(canvas.width/2-130, 85, 260, 45, COLORS.alert);
                ctx.fillStyle = COLORS.alert; ctx.font = "bold 20px 'Courier New'";
                ctx.fillText("[!] ABORT_SIMULATION", canvas.width / 2, 110);
                state.buttons.push({ x: canvas.width/2 - 125, y: 85, w: 250, h: 50, onClick: () => startEndingSequence() });
            } else {
                const nextCost = getNextStageCost(state.uptimeLevel);
                if (state.totalRuInception >= nextCost) drawPulseBox(canvas.width/2 - 200, 85, 400, 40, COLORS.phosphor);
                ctx.fillStyle = state.totalRuInception >= nextCost ? COLORS.phosphor : COLORS.dim;
                ctx.fillText(`NEXT: [${MILESTONES[state.uptimeLevel+1].name}] REQ: ${Math.floor(nextCost)} CRU`, canvas.width / 2, 110);
                state.buttons.push({ x: canvas.width/2 - 200, y: 85, w: 400, h: 40, onClick: () => { if (!state.isPaused && state.totalRuInception >= nextCost) { state.uptimeLevel++; recordStageChange(); if (MILESTONES[state.uptimeLevel].name === "WAR_GAMES") state.isWarGames = true; } } });
            }
            if (!state.isWarGames) {
                const m = (1 + (state.directives.velocity * 0.5));
                let pr = 0; state.upgrades.forEach(u => pr += u.count * u.ruPerSec * m);
                ctx.font = "18px 'Courier New'"; ctx.fillStyle = COLORS.phosphor;
                ctx.fillText(`RU: ${Math.floor(state.ru)} | TP: ${pr.toFixed(1)} RU/s`, canvas.width / 2, 310);
            }
            const bX = canvas.width / 2 - 240, bY = 360;
            ctx.strokeStyle = COLORS.dim; ctx.strokeRect(bX, bY, 480, 22);
            ctx.fillStyle = state.isFrozen ? COLORS.alert : COLORS.phosphor;
            ctx.fillRect(bX+4, bY+4, 472 * (state.errorBudget / (100 + state.directives.reliability * 10)), 14);
            const box = state.infraBox;
            ctx.save(); ctx.textAlign = "left"; ctx.fillStyle = COLORS.dim; ctx.fillText("--- INFRA-GRID TERMINAL ---", box.x, box.y - 10);
            ctx.strokeStyle = COLORS.dim; ctx.strokeRect(box.x - 5, box.y - 5, box.w + 10, box.h + 10);
            ctx.beginPath(); ctx.rect(box.x, box.y, box.w, box.h); ctx.clip();
            state.upgrades.forEach((u, i) => {
                const iY = box.y + 30 + i * 55 + state.infraScroll;
                const unlocked = state.uptimeLevel >= u.req;
                if (unlocked && !state.isWarGames) {
                    if (state.ru >= u.cost) drawPulseBox(box.x + 5, iY - 25, box.w - 40, 40, COLORS.phosphor);
                    ctx.fillStyle = state.ru >= u.cost ? COLORS.phosphor : COLORS.dim;
                    ctx.fillText(`[${u.count}] ${u.name} (${Math.floor(u.cost)} RU)`, box.x + 10, iY);
                    if (iY > box.y && iY < box.y + box.h) state.buttons.push({ x: box.x, y: iY - 30, w: box.w - 30, h: 40, onClick: () => { if (!state.isPaused && state.ru >= u.cost) { state.ru -= u.cost; u.count++; u.cost *= 2.3; } } });
                } else if (!state.isWarGames) { ctx.fillStyle = COLORS.locked; ctx.fillText(`[LOCKED] REQ: ${MILESTONES[u.req].name}`, box.x + 10, iY); }
            }); ctx.restore();
            const rX = canvas.width - 250, uiY = canvas.height - 300;
            ctx.textAlign = "center"; ctx.fillStyle = COLORS.dim; ctx.fillText("--- SELF-HEALING ---", rX, uiY);
            if (state.uptimeLevel >= 4 && !state.isWarGames) {
                if (state.logicFragments >= state.autoHeal.cost) drawPulseBox(rX - 105, uiY + 5, 210, 50, COLORS.prestige);
                ctx.fillStyle = state.logicFragments >= state.autoHeal.cost ? COLORS.prestige : COLORS.dim;
                ctx.fillText(`[LVL ${state.autoHeal.level}] AUTO-REMEDIATOR`, rX, uiY + 30);
                state.buttons.push({ x: rX - 100, y: uiY + 15, w: 200, h: 40, onClick: () => { if (state.logicFragments >= state.autoHeal.cost) { state.logicFragments -= state.autoHeal.cost; state.autoHeal.level++; state.autoHeal.power += 0.2; state.autoHeal.cost = Math.floor(state.autoHeal.cost * 2.2); } } });
            }
            if (state.uptimeLevel >= 3 && !state.isWarGames) {
                const pY = uiY + 120; drawPulseBox(rX - 200, pY - 5, 400, 40, COLORS.prestige);
                ctx.fillStyle = COLORS.prestige; ctx.fillText(`[!] GLOBAL POST-MORTEM`, rX, pY + 20);
                state.buttons.push({ x: rX - 200, y: pY, w: 400, h: 30, onClick: prestige });
            }
            ctx.textAlign = "right"; ctx.fillStyle = COLORS.white;
            ctx.fillText(state.isPaused ? "[RESUME]" : "[STANDUP]", canvas.width - 50, 45);
            state.buttons.push({ x: canvas.width - 250, y: 30, w: 200, h: 30, onClick: () => state.isPaused = !state.isPaused });
            ctx.fillStyle = state.debugMenuOpen ? COLORS.psycho : COLORS.gray;
            ctx.fillText("[DEBUG_SHELL]", canvas.width - 50, 80);
            state.buttons.push({ x: canvas.width - 250, y: 65, w: 200, h: 30, onClick: () => { state.debugMenuOpen = !state.debugMenuOpen; state.stageSelectOpen = false; } });
            if (state.debugMenuOpen) {
                const mX = canvas.width - 260, mY = 100, mW = 220, mH = 180;
                ctx.fillStyle = COLORS.bg; ctx.strokeStyle = COLORS.psycho;
                ctx.fillRect(mX, mY, mW, mH); ctx.strokeRect(mX, mY, mW, mH);
                ctx.fillStyle = state.demo.active ? COLORS.psycho : COLORS.white; ctx.textAlign = "center";
                ctx.fillText(state.demo.active ? "STOP_DEMO" : "START_DEMO", mX + mW/2, mY + 30);
                state.buttons.push({ x: mX + 10, y: mY + 10, w: mW - 20, h: 30, onClick: () => { state.demo.active = !state.demo.active; } });
                [1, 10, 100].forEach((s, i) => {
                    const x = mX + 40 + i * 70; ctx.fillStyle = state.gameSpeed === s ? COLORS.phosphor : COLORS.gray;
                    ctx.fillText(`${s}x`, x, mY + 70);
                    state.buttons.push({ x: x - 30, y: mY + 50, w: 60, h: 30, onClick: () => state.gameSpeed = s });
                });
                ctx.fillStyle = state.stageSelectOpen ? COLORS.psycho : COLORS.white;
                ctx.fillText("JUMP_TO_STAGE", mX + mW/2, mY + 110);
                state.buttons.push({ x: mX + 10, y: mY + 90, w: mW - 20, h: 30, onClick: () => state.stageSelectOpen = !state.stageSelectOpen });
                if (state.stageSelectOpen) {
                    const lX = mX - 220, lW = 210, lH = 400;
                    ctx.fillStyle = COLORS.bg; ctx.strokeStyle = COLORS.psycho;
                    ctx.fillRect(lX, mY, lW, lH); ctx.strokeRect(lX, mY, lW, lH);
                    MILESTONES.forEach((m, i) => {
                        ctx.fillStyle = state.uptimeLevel === i ? COLORS.phosphor : COLORS.white; ctx.font = "10px 'Courier New'";
                        ctx.fillText(`${i}: ${m.name}`, lX + lW/2, mY + 25 + i * 28);
                        state.buttons.push({ x: lX + 5, y: mY + 10 + i * 28, w: lW - 10, h: 25, onClick: () => jumpToStage(i) });
                    });
                }
            }
            drawBroccoli(canvas.width - 250, canvas.height - 450, state.uptimeLevel);
            ctx.textAlign = "left"; ctx.fillStyle = COLORS.dim; ctx.font = "12px 'Courier New'";
            state.terminalLines.forEach((l, i) => ctx.fillText(l, canvas.width - 400, canvas.height - 80 + i * 18)); ctx.restore();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        loop();
    </script>
</body>
</html>
